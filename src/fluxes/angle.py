'''Module that sets up a new grid from points on the separatrix and calculates fluxes. 

This grid is generated by using separatrix points that are equidistant in angle. We can prescribe the desired angular separation between points. It contains methods for the calculation of drifts and fluxes on this grid. 
It needs the core module since this is the one that does the loading of data.
'''
import numpy as np
import math
import pylab as py
from matplotlib.tri import Triangulation, LinearTriInterpolator
import matplotlib.pyplot as plt
from scipy.interpolate import splrep, splev, splprep, interp1d
from scipy.optimize import curve_fit
import sys
import numpy.ma as ma
from decimal import Decimal
import cProfile
import xgc
import core

'''Functions that set up the grid.'''
def angle_diff(max_angle, min_angle):
    '''Finds the angle range between a max and a min angle but takes into account different signs.'''
    temp = 0
    if max_angle<min_angle:
        temp = max_angle
        max_angle = min_angle
        min_angle = temp
    if max_angle>=0:
        if min_angle<0:
            an_range = max_angle + abs(min_angle)
        else:
            an_range = max_angle - min_angle
    else:
        an_range = abs(abs(max_angle) - abs(min_angle))
    
    return an_range

def norm_atan(y,x):
    '''Returns the angle formed between a vector with end coordinates x,y and the ray starting at the origin and passing through the
       point(1,0). The angle is between 0 and 360 degrees and the function can also take arrays.
    '''
    angle = np.degrees(np.arctan2(y,x))
    try:
        for index, elem in enumerate(angle):
            if elem<0:
                angle[index] = 360+elem
            else:
                pass
    except TypeError:
        if angle<0:
            angle = 360+angle
        else:
            pass
    
    return angle

def filtro(arr):
    '''Filter function that corrects the bug when angles are passing from 360 to 0.'''
    if arr.max()>300 and arr.min()<100:
        for elem in np.nditer(arr,op_flags=['readwrite']):
            if elem > 300:
                elem[...] = elem - 360
    
    return arr

def spline_creation(verbose = True):
    '''Creates a spline from the separatrix nodes and a fine mesh of points where the spline is evaluated. Then, chooses on which
       of these points the flux is going to be calculated according to the step in angle and returns only those. Those points are
       equidistant in poloidal angle. The verbose option plots the spline and the separatrix.
    '''
    angle_step = 1.0
    R_point=core.loader.RZ[core.sepInds,0]-core.Rmaj
    Z_point=core.loader.RZ[core.sepInds,1]
    minR = np.amin(R_point)
    minZ = np.amin(Z_point)
    maxR = np.amax(R_point)
    maxZ = np.amax(Z_point)
    RO = np.asarray(R_point)
    ZE = np.asarray(Z_point)
    
    angle = filtro(norm_atan(ZE,RO))
    angle_i = np.arange(angle.min(),angle.max(),angle_step)
    xi = interp1d(angle, RO, kind='cubic')(angle_i)
    yi = interp1d(angle, ZE, kind='cubic')(angle_i)

    R_fp = xi
    Z_fp = yi

    #test what is the distance between angles
    #AAA = angle[ind_list]
    #newA=[]
    #for i in range(0,len(AAA)-1):
        #newA.append(angle_diff(AAA[i],AAA[i+1]))
    #print(np.mean(newA))
    if verbose==True:
        plt.title("Spline between  %s-%s" %(minR,maxR))
        fig, ax =plt.subplots()
        ax.plot(xi[:],yi[:],'r-',label='spline')
        ax.plot(R_fp[:],Z_fp[:],'ms',label='angle mesh')
        ax.plot(core.loader.RZ[core.sepInds,0]-core.Rmaj,core.loader.RZ[core.sepInds,1],'b--',label='Separatrix')
        legend = ax.legend()
        plt.savefig("Spline_%s_to_%s.png" %(minR,maxR))
        plt.show()
    else:
        pass
    
    return R_fp, Z_fp

def angle_mesh():
    '''Creates the angle mesh.'''
    global R_fp, Z_fp, RA, ZA, num_fl_pts
    R_fp, Z_fp = spline_creation(False)
    num_fl_pts = len(R_fp)
    (RA,ZA) = np.meshgrid(R_fp + core.Rmaj,Z_fp)
    print("Number of Flux points:",num_fl_pts)
    
'''Smoothing functions.'''

def smoothing_alg(L):
    '''Algorithm for smoothing values.'''
    LF = np.roll(L,1)
    LB = np.roll(L,-1)
    LFF = np.roll(L,2)
    LBB = np.roll(L,-1)
    newL = (2.0*(LF + LB)+LFF+LBB)/6.0
    return newL

def smooth(L,n):
    '''Performs the smoothing algorithm n times on the matrix L.'''
    sL = L
    for i in range(0,int(n)):
        sL = smoothing_alg(sL)
    return sL


'''Next three functions are utilities for visualizing the grid.'''
    
def coord_of_mesh(ang_R,ang_Z,rect_R,rect_Z):
    '''Gives the coordinates of any point on the angular mesh and the rectangular mesh.'''
    print("coordinates of point of angular mesh:", "R = ", RA[ang_Z][ang_R],"Z = ", ZA[ang_Z][ang_R])
    print("coordinates of point of rectang. mesh:", "R = ", core.RI[rect_Z][rect_R], "Z = ", core.ZI[rect_Z][rect_R])
    
def plot_mesh_lines():
    '''Plots lines that connect to the mesh points in order to visualize that the are equidistant in angle.'''
    R_fp, Z_fp = spline_creation()
    for i in range(len(R_fp)):
        plt.title("Angle mesh that follows the separatrix")
        plt.xlabel("$R (m)$")
        plt.ylabel("$Z (m)$")
        plt.plot([0,R_fp[i]+core.Rmaj],[0,Z_fp[i]],R_fp[:]+core.Rmaj,Z_fp[:],'ms')
    plt.show() 

def two_mesh_plot():
    '''Plots the angular and the rectangular grids for comparison.'''
    x1 = core.RI
    y1 = core.ZI
    x2 = RA
    y2 = ZA
    x3 = R_fp+core.Rmaj
    y3 = Z_fp
    fig, ax = plt.subplots()
    plt.title('The two grids')
    plt.xlabel("R(m)")
    plt.ylabel("Z(m)")
    ax.scatter(x1,y1,color='b',label='rect. grid')
    ax.scatter(x2,y2,color='r',label='angle grid')
    ax.scatter(x3,y3,color='g',label='sep.points')
    legend = ax.legend()
    plt.show()
        

def derivatives(array,zi,it,cut):
    '''Returns arrays of d/dR and d/dZ derivatives of an array along a cut, at plane = iz, time = it. Arrays commonly taken from core.
    In the future, I plan to replace all derivatives calculations with this single function.
    '''
    global RA, ZA, R_fp, Z_fp, pot, bfield, B2
    option = 2
    
    Rp = np.roll(R_fp,1)
    Rm = np.roll(R_fp,-1)
    dRp = R_fp-Rp
    dRm = Rm - R_fp

    Zp = np.roll(Z_fp,1)
    Zm = np.roll(Z_fp,-1)
    dZp = Z_fp-Zp
    dZm = Zm - Z_fp
    
    arri = core.getcutvalue_hor(array[:,iz,it],cut,option)
    
    darrdR = []
    for i in range(1,len(arri)-1):
        A = dRp[i+1]/(dRm[i-1]**2 + dRp[i+1]*dRm[i-1]) - dRm[i-1]/(dRp[i+1]**2 + dRp[i+1]*dRm[i-1])
        B = -dRp[i+1]/(dRm[i-1]**2 + dRp[i+1]*dRm[i-1])
        C = dRm[i-1]/(dRp[i+1]**2 + dRp[i+1]*dRm[i-1])
        darrdR.append(A*arri[i] + B*arri[i-1] + C*arri[i+1])
    darrdR.append((arri[-1]-arri[-2])/dRp[-1])
    darrdR = [(arri[1]-arri[0])/dRm[0]] + darrdR
    
    arrim1 = core.getcutvalue_hor(array[:,iz,it],cut-1,option)
    arrip1 = core.getcutvalue_hor(array[:,iz,it],cut+1,option)
    D = dZp[cut+1]/(dZm[cut-1]**2 + dZp[cut+1]*dZm[cut-1]) - dZm[cut-1]/(dZp[cut+1]**2 + dZp[cut+1]*dZm[cut-1])
    E = -dZp[cut+1]/(dZm[cut-1]**2 + dZp[cut+1]*dZm[cut-1])
    F = dZm[cut-1]/(dZp[cut+1]**2 + dZp[cut+1]*dZm[cut-1])
    darrdZ = D*arri + E*arrim1 + F*arrip1
    
    darrdR = np.asarray(darrdZ)
    darrdZ = np.asarray(darrdZ)
    
    return darrdR, darrdZ
        
        
    '''Next two functions are used to convert data from f3d files(written on half planes), so that they are used with data from 3d
       files.
    '''    

def map_array(array,iz,it,cut):
    '''Takes an array at time = it, on a plane = iz and returns it's value at the half plane forward assuming that the values stay
       constant along field lines. Used to map the temperature values of the f3d files. Works on the angular grid.
    '''   
    global RA, ZA, R_fp, Z_fp, pot, bfield, B2
    option = 2
    
    dzeta = (2*math.pi)/core.Nplanes

    Rp = np.roll(R_fp,1)
    Rm = np.roll(R_fp,-1)
    dRp = R_fp-Rp
    dRm = Rm - R_fp

    Zp = np.roll(Z_fp,1)
    Zm = np.roll(Z_fp,-1)
    dZp = Z_fp-Zp
    dZm = Zm - Z_fp
    
    arri = core.getcutvalue_hor(array[:,iz,it],cut,option)
    darrdR = []
    for i in range(1,len(arri)-1):
        A = dRp[i+1]/(dRm[i-1]**2 + dRp[i+1]*dRm[i-1]) - dRm[i-1]/(dRp[i+1]**2 + dRp[i+1]*dRm[i-1])
        B = -dRp[i+1]/(dRm[i-1]**2 + dRp[i+1]*dRm[i-1])
        C = dRm[i-1]/(dRp[i+1]**2 + dRp[i+1]*dRm[i-1])
        darrdR.append(A*arri[i] + B*arri[i-1] + C*arri[i+1])
    darrdR.append((arri[-1]-arri[-2])/dRp[-1])
    darrdR = [(arri[1]-arri[0])/dRm[0]] + darrdR
    
    arrim1 = core.getcutvalue_hor(array[:,iz,it],cut-1,option)
    arrip1 = core.getcutvalue_hor(array[:,iz,it],cut+1,option)
    D = dZp[cut+1]/(dZm[cut-1]**2 + dZp[cut+1]*dZm[cut-1]) - dZm[cut-1]/(dZp[cut+1]**2 + dZp[cut+1]*dZm[cut-1])
    E = -dZp[cut+1]/(dZm[cut-1]**2 + dZp[cut+1]*dZm[cut-1])
    F = dZm[cut-1]/(dZp[cut+1]**2 + dZp[cut+1]*dZm[cut-1])
    darrdZ = D*arri + E*arrim1 + F*arrip1

    arriF = core.getcutvalue_hor(array[:,(iz+1)%core.Nplanes,it],cut,option)
    darrdRF = []
    for i in range(1,len(arriF)-1):
        A = dRp[i+1]/(dRm[i-1]**2 + dRp[i+1]*dRm[i-1]) - dRm[i-1]/(dRp[i+1]**2 + dRp[i+1]*dRm[i-1])
        B = -dRp[i+1]/(dRm[i-1]**2 + dRp[i+1]*dRm[i-1])
        C = dRm[i-1]/(dRp[i+1]**2 + dRp[i+1]*dRm[i-1])
        darrdRF.append(A*arriF[i] + B*arriF[i-1] + C*arriF[i+1])
    darrdRF.append((arriF[-1]-arriF[-2])/dRp[-1])
    darrdRF = [(arriF[1]-arriF[0])/dRm[0]] + darrdRF
    
    arrim1F = core.getcutvalue_hor(array[:,(iz+1)%core.Nplanes,it],cut-1,option)
    arrip1F = core.getcutvalue_hor(array[:,(iz+1)%core.Nplanes,it],cut+1,option)
    D = dZp[cut+1]/(dZm[cut-1]**2 + dZp[cut+1]*dZm[cut-1]) - dZm[cut-1]/(dZp[cut+1]**2 + dZp[cut+1]*dZm[cut-1])
    E = -dZp[cut+1]/(dZm[cut-1]**2 + dZp[cut+1]*dZm[cut-1])
    F = dZm[cut-1]/(dZp[cut+1]**2 + dZp[cut+1]*dZm[cut-1])
    darrdZF = D*arriF + E*arrim1F + F*arrip1F

    BRi = core.getcutvalue_hor(core.bfield[:,0],cut,option)
    BZi = core.getcutvalue_hor(core.bfield[:,1],cut,option)
    Bzetai = core.getcutvalue_hor(core.bfield[:,2],cut,option)
    #Major Radius
    R_n = R_fp+core.Rmaj
    
    Sigma = R_n*(-(BRi/Bzetai)*darrdR - (BZi/Bzetai)*darrdZ)
    SigmaF = R_n*(-(BRi/Bzetai)*darrdRF - (BZi/Bzetai)*darrdZF)
    arr_half = (arri+arriF)/2 + (1/4)*(Sigma - SigmaF)*dzeta
    
    return arr_half


    '''Next two functions calculate particle drifts on the angular mesh.'''

def getcutvRvZ(iz,it,cut):
    '''Calculates the EXB velocity on the angle mesh along a cut, at time = it and plane = iz. Returns R and Z components.'''
    global RA, ZA, R_fp, Z_fp, pot, bfield, B2
    option = 2
    
    Rp = np.roll(R_fp,1)
    Rm = np.roll(R_fp,-1)
    dRp = R_fp-Rp
    dRm = Rm - R_fp

    Zp = np.roll(Z_fp,1)
    Zm = np.roll(Z_fp,-1)
    dZp = Z_fp-Zp
    dZm = Zm - Z_fp
    
    poti = core.getcutvalue_hor(core.pot[:,iz,it],cut,option)
    dphidR = []
    for i in range(1,len(poti)-1):
        A = dRp[i+1]/(dRm[i-1]**2 + dRp[i+1]*dRm[i-1]) - dRm[i-1]/(dRp[i+1]**2 + dRp[i+1]*dRm[i-1])
        B = -dRp[i+1]/(dRm[i-1]**2 + dRp[i+1]*dRm[i-1])
        C = dRm[i-1]/(dRp[i+1]**2 + dRp[i+1]*dRm[i-1])
        dphidR.append(A*poti[i] + B*poti[i-1] + C*poti[i+1])
    dphidR.append((poti[-1]-poti[-2])/dRp[-1])
    dphidR = [(poti[1]-poti[0])/dRm[0]] + dphidR
    
    potim1 = core.getcutvalue_hor(core.pot[:,iz,it],cut-1,option)
    potip1 = core.getcutvalue_hor(core.pot[:,iz,it],cut+1,option)
    D = dZp[cut+1]/(dZm[cut-1]**2 + dZp[cut+1]*dZm[cut-1]) - dZm[cut-1]/(dZp[cut+1]**2 + dZp[cut+1]*dZm[cut-1])
    E = -dZp[cut+1]/(dZm[cut-1]**2 + dZp[cut+1]*dZm[cut-1])
    F = dZm[cut-1]/(dZp[cut+1]**2 + dZp[cut+1]*dZm[cut-1])
    dphidZ = D*poti + E*potim1 + F*potip1
    
    dphidzeta = 0

    BRi = core.getcutvalue_hor(core.bfield[:,0],cut,option)
    BZi = core.getcutvalue_hor(core.bfield[:,1],cut,option)
    Bzetai = core.getcutvalue_hor(core.bfield[:,2],cut,option)
    
    #1/R dphidzeta is calculated by taking parallel gradient of phi to be zero.
    Bzobzet2 = (BZi/Bzetai)**2
    Brobzet2 = (BRi/Bzetai)**2
    BrBzobzet2 = (BRi*BZi)/(Bzetai**2)
    B2 = BRi**2 + BZi**2 + Bzetai**2
    
    #velocities needed for the calculation of the turbulent component. Based on \nabla_{\parallel} \delta \phi = 0.
    tvRi = (Bzetai/B2)*(dphidZ*(1.+Bzobzet2)+BrBzobzet2*dphidR)
    tvZi = -(Bzetai/B2)*(dphidR*(1.+Brobzet2)+BrBzobzet2*dphidZ)
    
    #actual equilibrium velocities
    vRi = (1/B2)*(Bzetai*dphidZ)
    vZi = -(1/B2)*(dphidR*Bzetai)
    
    return(vRi,vZi,tvRi,tvZi, dphidR, dphidZ, poti)

def magnetic_drifts_angle(cut,ip_value):
    '''Calculates all components of the magnetic drifts at a point = ip_value on a cut = cut. '''
    global RA, ZA, R_fp, Z_fp, pot, bfield, B2
    option=2
    
    #quantities needed for the calculation of derivatives.
    Rp = np.roll(R_fp,1)
    Rm = np.roll(R_fp,-1)
    dRp = R_fp-Rp
    dRm = Rm - R_fp

    Zp = np.roll(Z_fp,1)
    Zm = np.roll(Z_fp,-1)
    dZp = Z_fp-Zp
    dZm = Zm - Z_fp
    
    D = dZp[cut+1]/(dZm[cut-1]**2 + dZp[cut+1]*dZm[cut-1]) - dZm[cut-1]/(dZp[cut+1]**2 + dZp[cut+1]*dZm[cut-1])
    E = -dZp[cut+1]/(dZm[cut-1]**2 + dZp[cut+1]*dZm[cut-1])
    F = dZm[cut-1]/(dZp[cut+1]**2 + dZp[cut+1]*dZm[cut-1])

    #Define constants, average temperatures and velocities on them.
    m_i = 2*1.6723e-27
    k = 1.38e-23
    joule_conv = 1.602e-19
    charge = 1.602176e-19 
    permeability = 1.2566e-6
    
    #Temperature profiles are constant so, it suffices to take avg. temp. at a single time point.
    Ti_perp_all = np.array([map_array(core.i_T_perp,(iz-1)%core.Nplanes, 0,cut)[ip_value] for iz in range(core.Nplanes)])
    Ei_para_all = np.array([map_array(core.i_E_para,(iz-1)%core.Nplanes, 0,cut)[ip_value] for iz in range(core.Nplanes)])
    Temperature = 2/3.*(Ti_perp_all + Ei_para_all)
    Ti_avg = Temperature.mean()
    Ti_prp_avg = Ti_perp_all.mean()
    Ti_prl_avg = 2*Ei_para_all.mean()
    
    V_th = np.sqrt((joule_conv*Ti_avg)/m_i)
    #print('V_th:', '%.2E' % Decimal(V_th))
    #print('Temp_ratio:','%.2E' % Decimal(Ti_prp_avg/Ti_prl_avg))
    V_perp_2 = (joule_conv*Ti_prp_avg)/m_i
    V_par_2 = (joule_conv*Ti_prl_avg)/m_i
    #print('V_perp_sq=','%.2E' % Decimal(V_perp_2))
    #print('V_par_sq=','%.2E' % Decimal(V_par_2))
    
    #Loading B-field, calculate values at the cut and find the gyrofrequency and gyroradius.
    Br = core.getcutvalue_hor(core.bfield[:,0],cut,option)
    Bz = core.getcutvalue_hor(core.bfield[:,1],cut,option)
    Bzeta = core.getcutvalue_hor(core.bfield[:,2],cut,option)
    BfMag=[]
    for i in range(len(Br)):
        BfMag.append(np.sqrt(Br[i]*Br[i] + Bz[i]*Bz[i] + Bzeta[i]*Bzeta[i]))
    BfMag = np.asarray(BfMag)
    #print('B:','%.2E' % Decimal(BfMag[ip_value]))
    Omega = np.asarray((charge*BfMag/(m_i)))
    #print('Omega:','%.2E' % Decimal(Omega[ip_value]))
    #print('rho:','%.2E' % Decimal(V_th/Omega[ip_value]))

    #finding J_perp/B for testing
   # i_pol_flow = loader.i_pol_f
   # e_pol_flow = loader.e_pol_f
   # i_pol_flow_av = i_pol_flow.mean(axis=0)
   # e_pol_flow_av = e_pol_flow.mean(axis=0)
   # n_e=loader.calcNeTotal()
   # ne_all = np.array([[getcutvalue(n_e[:,iz,it],cut)[Flux_ip] for iz in range(Nplanes)] for it in range(0,130)])
   # ne_int = ne_all.mean(axis=0)
   # ne = ne_int.mean(axis=0)
    #print('ne',ne_all.shape)
   # J_perp = ne*charge*(i_pol_flow_av[oned_location]-e_pol_flow_av[oned_location])*permeability
   # print('i_poloidal:','%.2E' % Decimal(i_pol_flow_av[oned_location]))
   # print('e_poloidal:','%.2E' % Decimal(e_pol_flow_av[oned_location]))
   # print('J_perp:','%.2E' % Decimal(J_perp))
   # print('J_perp/B:','%.2E' % Decimal(J_perp/BfMag[Flux_ip]))


    '''Calculating the gradients of scalar |B| and dbr/dZ, dbr/dR, dbz/dZ, dbz/dR, dbzeta/dZ, dbzeta/dR.'''
    #dB/dZ
    Brm1 = core.getcutvalue_hor(core.bfield[:,0],cut-1,option)
    Bzm1 = core.getcutvalue_hor(core.bfield[:,1],cut-1,option)
    Bzetam1 = core.getcutvalue_hor(core.bfield[:,2],cut-1,option)
    BfMagm1=[]
    for i in range(len(Brm1)):
        BfMagm1.append(np.sqrt(Brm1[i]*Brm1[i] + Bzm1[i]*Bzm1[i] + Bzetam1[i]*Bzetam1[i]))
    BMm1 = np.asarray(BfMagm1)
    brm1 = Brm1/BMm1
    bzm1 = Bzm1/BMm1
    bzetam1 = Bzetam1/BMm1
    Br = core.getcutvalue_hor(core.bfield[:,0],cut,option)
    Bz = core.getcutvalue_hor(core.bfield[:,1],cut,option)
    Bzeta = core.getcutvalue_hor(core.bfield[:,2],cut,option)
    BfMag=[]
    for i in range(len(Br)):
        BfMag.append(np.sqrt(Br[i]*Br[i] + Bz[i]*Bz[i] + Bzeta[i]*Bzeta[i]))
    BM = np.asarray(BfMag)
    br = np.asarray(Br/BM)
    bz = np.asarray(Bz/BM)
    bzeta = np.asarray(Bzeta/BM)
    lenBM = len(BM)
    lenbr = len(br)
    lenbz = len(bz)
    lenbzeta = len(bzeta)
    Brp1 = core.getcutvalue_hor(core.bfield[:,0],cut+1,option)
    Bzp1 = core.getcutvalue_hor(core.bfield[:,1],cut+1,option)
    Bzetap1 = core.getcutvalue_hor(core.bfield[:,2],cut+1,option)
    BfMagp1=[]
    for i in range(len(Brp1)):
        BfMagp1.append(np.sqrt(Brp1[i]*Brp1[i] + Bzp1[i]*Bzp1[i] + Bzetap1[i]*Bzetap1[i]))
    BMp1 = np.asarray(BfMagp1)
    brp1 = Brp1/BMp1
    bzp1 = Bzp1/BMp1
    bzetap1 = Bzetap1/BMp1
    dBdZ = D*BM + E*BMm1 + F*BMp1
    dbrdZ = D*br + E*brm1 + F*brp1
    dbzdZ = D*bz + E*bzm1 + F*bzp1
    dbzetadZ = D*bzeta + E*bzetam1 + F*bzetap1
    dBdZ = np.asarray(dBdZ)
    dbrdZ = np.asarray(dbrdZ)
    dbzdZ = np.asarray(dbzdZ)
    dbzetadZ = np.asarray(dbzetadZ)
    
    # dB/dR
    dBdR=[]
    dbrdR=[]
    dbzdR=[]
    dbzetadR=[]
    
    for i in range(1,len(BM)-1):
        A = dRp[i+1]/(dRm[i-1]**2 + dRp[i+1]*dRm[i-1]) - dRm[i-1]/(dRp[i+1]**2 + dRp[i+1]*dRm[i-1])
        B = -dRp[i+1]/(dRm[i-1]**2 + dRp[i+1]*dRm[i-1])
        C = dRm[i-1]/(dRp[i+1]**2 + dRp[i+1]*dRm[i-1])
        dBdR.append(A*BM[i] + B*BM[i-1] + C*BM[i+1])
    dBdR.append((BM[-1]-BM[-2])/dRp[-1])
    dBdR = [(BM[1]-BM[0])/dRm[0]] + dBdR

    for i in range(1,len(br)-1):
        A = dRp[i+1]/(dRm[i-1]**2 + dRp[i+1]*dRm[i-1]) - dRm[i-1]/(dRp[i+1]**2 + dRp[i+1]*dRm[i-1])
        B = -dRp[i+1]/(dRm[i-1]**2 + dRp[i+1]*dRm[i-1])
        C = dRm[i-1]/(dRp[i+1]**2 + dRp[i+1]*dRm[i-1])
        dbrdR.append(A*br[i] + B*br[i-1] + C*br[i+1])
    dbrdR.append((br[-1]-br[-2])/dRp[-1])
    dbrdR = [(br[1]-br[0])/dRm[0]] + dbrdR

    for i in range(1,len(bz)-1):
        A = dRp[i+1]/(dRm[i-1]**2 + dRp[i+1]*dRm[i-1]) - dRm[i-1]/(dRp[i+1]**2 + dRp[i+1]*dRm[i-1])
        B = -dRp[i+1]/(dRm[i-1]**2 + dRp[i+1]*dRm[i-1])
        C = dRm[i-1]/(dRp[i+1]**2 + dRp[i+1]*dRm[i-1])
        dbzdR.append(A*bz[i] + B*bz[i-1] + C*bz[i+1])
    dbzdR.append((bz[-1]-bz[-2])/dRp[-1])
    dbzdR = [(bz[1]-bz[0])/dRm[0]] + dbzdR
    
    for i in range(1,len(bzeta)-1):
        A = dRp[i+1]/(dRm[i-1]**2 + dRp[i+1]*dRm[i-1]) - dRm[i-1]/(dRp[i+1]**2 + dRp[i+1]*dRm[i-1])
        B = -dRp[i+1]/(dRm[i-1]**2 + dRp[i+1]*dRm[i-1])
        C = dRm[i-1]/(dRp[i+1]**2 + dRp[i+1]*dRm[i-1])
        dbzetadR.append(A*bzeta[i] + B*bzeta[i-1] + C*bzeta[i+1])
    dbzetadR.append((bzeta[-1]-bzeta[-2])/dRp[-1])
    dbzetadR = [(bzeta[1]-bzeta[0])/dRm[0]] + dbzetadR
    
    dbrdR = np.asarray(dbrdR)
    dbzdR = np.asarray(dbzdR)   
    dbzetadR = np.asarray(dbzetadR)
    dBdR = np.asarray(dBdR)

    #dBdzeta
    dBdzeta = 0
    dbrdzeta = 0
    dbzdzeta = 0
    dbzetadzeta = 0
    
    #Major Radius
    R_n = R_fp+core.Rmaj
    
    '''Calculation of gradBr, gradBz, gradBzeta drifts.'''
    #calculation of b X gradB
    crossR = (-bz*(dBdzeta/R_n) + bzeta*dBdZ)
    crossZ = (-dBdR*bzeta + br*(dBdzeta/R_n))
    crosszeta = (dBdR*bz - dBdZ*br)
    
    #calculation of geometric portion of gradB drifts (they need to be multiplied by v_perp^2 to be made drifts), 1/Omega (b X gradB)/B
    gradBR = (1/Omega)*(crossR/BM)
    gradBZ = (1/Omega)*(crossZ/BM)
    gradBzeta = (1/Omega)*(crosszeta/BM)
    
    #real drifts. Disable if you only want geometric effect.
    gradBR = gradBR*V_perp_2
    gradBZ = gradBZ*V_perp_2
    gradBzeta = gradBzeta*V_perp_2
    
    '''Calculation of curvature drifts:
    b*delb
    b*Del = br*d/dr+bz*d/dz+bzeta*d/dzeta
    (b*Del)(br,bz,bzeta) = 
    R_comp= br*dbrdR+bz*dbrdZ+(bzeta/R)*dbrdzeta - (bzeta*bzeta)/R
    Z_comp =  br*dbzdR+bz*dbzdZ+(bzeta/R)*dbzdzeta
    zeta_com = br*dbzetadR+bz*dbzetadZ+(bzeta/R)*dbzetadzeta +(bzeta*br)/R.
    '''
    #(1/Omega)*bX(b*Del)b= (they need to be multiplied by v_par^2 to be made into drifts)
    curvR = (-bz*(br*dbzetadR+bz*dbzetadZ+(bzeta/R_n)*dbzetadzeta+(bzeta*br)/R_n)+bzeta*(br*dbzdR+bz*dbzdZ+(bzeta/R_n)*dbzdzeta))*(1/Omega)    
    curvZ = (-bzeta*(br*dbrdR+bz*dbrdZ+(bzeta/R_n)*dbrdzeta - (bzeta*bzeta)/R_n)+br*(br*dbzetadR+bz*dbzetadZ+(bzeta/R_n)*dbzetadzeta+(bzeta*br)/R_n))*(1/Omega)
    curvzeta = (-br*(br*dbzdR+bz*dbzdZ+(bzeta/R_n)*dbzdzeta)+bz*(br*dbrdR+bz*dbrdZ+(bzeta/R_n)*dbrdzeta - (bzeta*bzeta)/R_n))*(1/Omega)

    #Real drifts. Disable if you only want geometric effect.
    curvR = curvR*V_par_2
    curvZ = curvZ*V_par_2
    curvzeta = curvzeta*V_par_2
    
    return gradBR[ip_value], gradBZ[ip_value], gradBzeta[ip_value], curvR[ip_value], curvZ[ip_value], curvzeta[ip_value]

def diamagnetic_drifts_angle(cut,ip_value):
    '''Calculates all components of the diamagnetic drifts at a point = ip_value on a cut = cut. Returns the values of the diamagnetic
    flux.
    '''
    global RA, ZA, R_fp, Z_fp, pot, bfield, B2
    option=2
    start = 0
    time_range = 2
    
    #quantities needed for the calculation of derivatives.
    Rp = np.roll(R_fp,1)
    Rm = np.roll(R_fp,-1)
    dRp = R_fp-Rp
    dRm = Rm - R_fp

    Zp = np.roll(Z_fp,1)
    Zm = np.roll(Z_fp,-1)
    dZp = Z_fp-Zp
    dZm = Zm - Z_fp
    
    D = dZp[cut+1]/(dZm[cut-1]**2 + dZp[cut+1]*dZm[cut-1]) - dZm[cut-1]/(dZp[cut+1]**2 + dZp[cut+1]*dZm[cut-1])
    E = -dZp[cut+1]/(dZm[cut-1]**2 + dZp[cut+1]*dZm[cut-1])
    F = dZm[cut-1]/(dZp[cut+1]**2 + dZp[cut+1]*dZm[cut-1])

    #Define constants, load temperatures and density.
    charge = 1 #Just work with eV is more convenient. 
    
    #Temperature profiles are constant so, it suffices to take avg. temp. at a single time point.
    Ti_perp_all = np.array([[map_array(core.i_T_perp,(iz-1)%core.Nplanes, it,cut) for iz in range(core.Nplanes)] for it in range(start,start+time_range)])
    Ei_para_all = np.array([[map_array(core.i_E_para,(iz-1)%core.Nplanes, it,cut) for iz in range(core.Nplanes)]for it in range(start,start+time_range)])
    Temperature = 2/3.*(Ti_perp_all + Ei_para_all)
    ne_all = np.array([[core.getcutvalue_hor(core.ne[:,iz,it],cut,option) for iz in range(core.Nplanes)]for it in range(start,start+time_range)])
    
    Temp_tor = Temperature.mean(axis=1)
    ne_tor = ne_all.mean(axis=1)
    
    Temp = Temp_tor.mean(axis=0)
    ne = ne_tor.mean(axis=0)
    
    Pi = np.multiply(Temp,ne)
    #print('P',Pi)
    #Replacing nan values with mean.
    #ind_c = np.where(np.isnan(Pi))
    #print('ind',ind_c)
    #mean_Pi = np.nanmean(Pi)
    #print(ind_c[0][0], ind_c[0][1])
    #print(ind_c[0].shape)
    #for i in range (len(ind_c[0])):
    #Pi[ind_c] = mean_Pi
    #Pi = smooth(Pi,20) #Smoothing Pi.
    #print('P_after',Pi)
    #Repeat for upper cut
    Ti_perp_all_p1 = np.array([[map_array(core.i_T_perp,(iz-1)%core.Nplanes, it, (cut+1)) for iz in range(core.Nplanes)] for it in range(start,start+time_range)])
    Ei_para_all_p1 = np.array([[map_array(core.i_E_para,(iz-1)%core.Nplanes, it, (cut+1)) for iz in range(core.Nplanes)] for it in range(start,start+time_range)])
    Temperature_p1 = 2/3.*(Ti_perp_all_p1 + Ei_para_all_p1)
    ne_all_p1 = np.array([[core.getcutvalue_hor(core.ne[:,iz,it],(cut+1),option) for iz in range(core.Nplanes)] for it in range(start,start+time_range)])
    
    Temp_tor_p1 = Temperature_p1.mean(axis=1)
    ne_tor_p1 = ne_all_p1.mean(axis=1)
    
    Temp_p1 = Temp_tor_p1.mean(axis=0)
    ne_p1 = ne_tor_p1.mean(axis=0)
    
    Pi_p1 = np.multiply(Temp_p1,ne_p1)
    #print('Pi_p1',Pi_p1)
    #Replacing nan values with mean.
    #ind_u = np.where(np.isnan(Pi_p1))
    #mean_Pi_p1 = np.nanmean(Pi_p1)
    #Pi_p1[ind_u] = mean_Pi_p1
    #Pi_p1 = smooth(Pi_p1,20)
    #print('Pi_p1_after',Pi_p1)
    #Repeat for lower cut
    Ti_perp_all_m1 = np.array([[map_array(core.i_T_perp,(iz-1)%core.Nplanes, it,(cut-1)) for iz in range(core.Nplanes)] for it in range(start,start+time_range)])
    Ei_para_all_m1 = np.array([[map_array(core.i_E_para,(iz-1)%core.Nplanes, it,(cut-1)) for iz in range(core.Nplanes)] for it in range(start,start+time_range)])
    Temperature_m1 = 2/3.*(Ti_perp_all_m1 + Ei_para_all_m1)
    ne_all_m1 = np.array([[core.getcutvalue_hor(core.ne[:,iz,it],(cut-1)%100,option) for iz in range(core.Nplanes)] for it in range(start,start+time_range)])
    
    Temp_tor_m1 = Temperature_m1.mean(axis=1)
    ne_tor_m1 = ne_all_m1.mean(axis=1)
    
    Temp_m1 = Temp_tor_m1.mean(axis=0)
    ne_m1 = ne_tor_m1.mean(axis=0)
    
    Pi_m1 = np.multiply(Temp_m1,ne_m1)
    #print('Pi_m1',Pi_m1)
    #Replacing nan values with mean.
    #ind_d = np.where(np.isnan(Pi_m1))
    #mean_Pi_m1 = np.nanmean(Pi_m1)
    #Pi_m1[ind_d] = mean_Pi_m1
    #Pi_m1 = smooth(Pi_m1,20)
    #print('Pi_m1_after',Pi_m1)
    #Loading B-field.
    Br = core.getcutvalue_hor(core.bfield[:,0],cut,option)
    #print('BR', Br)
    Bz = core.getcutvalue_hor(core.bfield[:,1],cut,option)
    #print('BZ', Bz)
    Bzeta = core.getcutvalue_hor(core.bfield[:,2],cut,option)
    #print('Bzeta', Bzeta)
    BfMag=[]
    for i in range(len(Br)):
        BfMag.append(np.sqrt(Br[i]*Br[i] + Bz[i]*Bz[i] + Bzeta[i]*Bzeta[i]))
    BfMag = np.asarray(BfMag)
    B_sq = BfMag**2
    Bp=np.array(np.sqrt(Br[:]*Br[:] + Bz[:]*Bz[:])) 
    #print('B', BfMag)
    #print('Bp', Bp)
    #print('BR/Bp', Br/Bp)
    #print('BZ/Bp', Bz/Bp)
    
    #dP/dZ
    dPdZ = D*Pi + E*Pi_m1 + F*Pi_p1
    #print('dPdZ', dPdZ)    
    #dP/dR
    dPdR = []
    for i in range(1,len(Pi)-1):
        A = dRp[i+1]/(dRm[i-1]**2 + dRp[i+1]*dRm[i-1]) - dRm[i-1]/(dRp[i+1]**2 + dRp[i+1]*dRm[i-1])
        B = -dRp[i+1]/(dRm[i-1]**2 + dRp[i+1]*dRm[i-1])
        C = dRm[i-1]/(dRp[i+1]**2 + dRp[i+1]*dRm[i-1])
        dPdR.append(A*Pi[i] + B*Pi[i-1] + C*Pi[i+1])
    dPdR.append((Pi[-1]-Pi[-2])/dRp[-1])
    dPdR = [(Pi[1]-Pi[0])/dRm[0]] + dPdR
    #print('dPdR', dPdR)
    
    #Major Radius
    R_n = R_fp+core.Rmaj
    #print('R', R_n)
    
    #print('Z', Z_fp)
    #1/R dP/dzeta
    dPdzeta_ov_R_turb = -((Br/Bzeta)*dPdR + (Bz/Bzeta)*dPdZ)
    dPdzeta_ov_R = 0
    #print('dPdzeta_ov_R',dPdzeta_ov_R)
    #print('dPdzeta_ov_R_tur',dPdzeta_ov_R_turb)
       
    #diamagnetic fluxes
    prefactor = 1/(charge*B_sq)
    
    diam_R = prefactor*(Bzeta*dPdZ - Bz*dPdzeta_ov_R)
    #print('diam_R',diam_R)
    diam_Z = prefactor*(Br*dPdzeta_ov_R - Bzeta*dPdR)
    #print('diam_Z',diam_Z)
    diam_zeta = prefactor*(Bz*dPdR-Br*dPdZ)
    #print('diam_zeta',diam_zeta)
    
    diam_N = (-Br*diam_Z + Bz*diam_R)/Bp    
    return diam_N[ip_value]

'''Next three functions compare all possible values between the two grids.'''

def angle_der(cut):
    '''Calculates all derivatives on the angle mesh along a cut. Only called in the comparison methods.'''
    #derivatives on angle mesh
    option = 2
    #quantities needed for the calculation of derivatives.
    Rp = np.roll(R_fp,1)
    Rm = np.roll(R_fp,-1)
    dRp = R_fp-Rp
    dRm = Rm - R_fp

    Zp = np.roll(Z_fp,1)
    Zm = np.roll(Z_fp,-1)
    dZp = Z_fp-Zp
    dZm = Zm - Z_fp
    
    D = dZp[cut+1]/(dZm[cut-1]**2 + dZp[cut+1]*dZm[cut-1]) - dZm[cut-1]/(dZp[cut+1]**2 + dZp[cut+1]*dZm[cut-1])
    E = -dZp[cut+1]/(dZm[cut-1]**2 + dZp[cut+1]*dZm[cut-1])
    F = dZm[cut-1]/(dZp[cut+1]**2 + dZp[cut+1]*dZm[cut-1])
    
    # dB/dZ
    Brm1 = core.getcutvalue_hor(core.bfield[:,0],cut-1,option)
    Bzm1 = core.getcutvalue_hor(core.bfield[:,1],cut-1,option)
    Bzetam1 = core.getcutvalue_hor(core.bfield[:,2],cut-1,option)
    BfMagm1=[]
    for i in range(len(Brm1)):
        BfMagm1.append(np.sqrt(Brm1[i]*Brm1[i] + Bzm1[i]*Bzm1[i] + Bzetam1[i]*Bzetam1[i]))
    BMm1 = np.asarray(BfMagm1)
    brm1 = Brm1/BMm1
    bzm1 = Bzm1/BMm1
    bzetam1 = Bzetam1/BMm1
    Br = core.getcutvalue_hor(core.bfield[:,0],cut,option)
    Bz = core.getcutvalue_hor(core.bfield[:,1],cut,option)
    Bzeta = core.getcutvalue_hor(core.bfield[:,2],cut,option)
    BfMag=[]
    for i in range(len(Br)):
        BfMag.append(np.sqrt(Br[i]*Br[i] + Bz[i]*Bz[i] + Bzeta[i]*Bzeta[i]))
    BM = np.asarray(BfMag)
    br = np.asarray(Br/BM)
    bz = np.asarray(Bz/BM)
    bzeta = np.asarray(Bzeta/BM)
    lenBM = len(BM)
    lenbr = len(br)
    lenbz = len(bz)
    lenbzeta = len(bzeta)
    Brp1 = core.getcutvalue_hor(core.bfield[:,0],cut+1,option)
    Bzp1 = core.getcutvalue_hor(core.bfield[:,1],cut+1,option)
    Bzetap1 = core.getcutvalue_hor(core.bfield[:,2],cut+1,option)
    BfMagp1=[]
    for i in range(len(Brp1)):
        BfMagp1.append(np.sqrt(Brp1[i]*Brp1[i] + Bzp1[i]*Bzp1[i] + Bzetap1[i]*Bzetap1[i]))
    BMp1 = np.asarray(BfMagp1)
    brp1 = Brp1/BMp1
    bzp1 = Bzp1/BMp1
    bzetap1 = Bzetap1/BMp1
    dBdZ = D*BM + E*BMm1 + F*BMp1
    dbrdZ = D*br + E*brm1 + F*brp1
    dbzdZ = D*bz + E*bzm1 + F*bzp1
    dbzetadZ = D*bzeta + E*bzetam1 + F*bzetap1
    
    dBdZ_an = np.asarray(dBdZ)
    dbrdZ_an = np.asarray(dbrdZ)
    dbzdZ_an = np.asarray(dbzdZ)
    dbzetadZ_an = np.asarray(dbzetadZ)
    
    # dB/dR
    dBdR=[]
    dbrdR=[]
    dbzdR=[]
    dbzetadR=[]
    
    for i in range(1,len(BM)-1):
        A = dRp[i+1]/(dRm[i-1]**2 + dRp[i+1]*dRm[i-1]) - dRm[i-1]/(dRp[i+1]**2 + dRp[i+1]*dRm[i-1])
        B = -dRp[i+1]/(dRm[i-1]**2 + dRp[i+1]*dRm[i-1])
        C = dRm[i-1]/(dRp[i+1]**2 + dRp[i+1]*dRm[i-1])
        dBdR.append(A*BM[i] + B*BM[i-1] + C*BM[i+1])
    dBdR.append((BM[-1]-BM[-2])/dRp[-1])
    dBdR = [(BM[1]-BM[0])/dRm[0]] + dBdR

    for i in range(1,len(br)-1):
        A = dRp[i+1]/(dRm[i-1]**2 + dRp[i+1]*dRm[i-1]) - dRm[i-1]/(dRp[i+1]**2 + dRp[i+1]*dRm[i-1])
        B = -dRp[i+1]/(dRm[i-1]**2 + dRp[i+1]*dRm[i-1])
        C = dRm[i-1]/(dRp[i+1]**2 + dRp[i+1]*dRm[i-1])
        dbrdR.append(A*br[i] + B*br[i-1] + C*br[i+1])
    dbrdR.append((br[-1]-br[-2])/dRp[-1])
    dbrdR = [(br[1]-br[0])/dRm[0]] + dbrdR

    for i in range(1,len(bz)-1):
        A = dRp[i+1]/(dRm[i-1]**2 + dRp[i+1]*dRm[i-1]) - dRm[i-1]/(dRp[i+1]**2 + dRp[i+1]*dRm[i-1])
        B = -dRp[i+1]/(dRm[i-1]**2 + dRp[i+1]*dRm[i-1])
        C = dRm[i-1]/(dRp[i+1]**2 + dRp[i+1]*dRm[i-1])
        dbzdR.append(A*bz[i] + B*bz[i-1] + C*bz[i+1])
    dbzdR.append((bz[-1]-bz[-2])/dRp[-1])
    dbzdR = [(bz[1]-bz[0])/dRm[0]] + dbzdR
    
    for i in range(1,len(bzeta)-1):
        A = dRp[i+1]/(dRm[i-1]**2 + dRp[i+1]*dRm[i-1]) - dRm[i-1]/(dRp[i+1]**2 + dRp[i+1]*dRm[i-1])
        B = -dRp[i+1]/(dRm[i-1]**2 + dRp[i+1]*dRm[i-1])
        C = dRm[i-1]/(dRp[i+1]**2 + dRp[i+1]*dRm[i-1])
        dbzetadR.append(A*bzeta[i] + B*bzeta[i-1] + C*bzeta[i+1])
    dbzetadR.append((bzeta[-1]-bzeta[-2])/dRp[-1])
    dbzetadR = [(bzeta[1]-bzeta[0])/dRm[0]] + dbzetadR
    
    dbrdR_an = np.asarray(dbrdR)
    dbzdR_an = np.asarray(dbzdR)   
    dbzetadR_an = np.asarray(dbzetadR)
    dBdR_an = np.asarray(dBdR)
    
    #Electric field
    poti = core.getcutvalue_hor(core.pot[:,0,0],cut,option)
    dphidR = []
    for i in range(1,len(poti)-1):
        A = dRp[i+1]/(dRm[i-1]**2 + dRp[i+1]*dRm[i-1]) - dRm[i-1]/(dRp[i+1]**2 + dRp[i+1]*dRm[i-1])
        B = -dRp[i+1]/(dRm[i-1]**2 + dRp[i+1]*dRm[i-1])
        C = dRm[i-1]/(dRp[i+1]**2 + dRp[i+1]*dRm[i-1])
        dphidR.append(A*poti[i] + B*poti[i-1] + C*poti[i+1])
    dphidR.append((poti[-1]-poti[-2])/dRp[-1])
    dphidR = [(poti[1]-poti[0])/dRm[0]] + dphidR
    dphidR_an = np.asarray(dphidR)
    
    potim1 = core.getcutvalue_hor(core.pot[:,0,0],cut-1,option)
    potip1 = core.getcutvalue_hor(core.pot[:,0,0],cut+1,option)
    D = dZp[cut+1]/(dZm[cut-1]**2 + dZp[cut+1]*dZm[cut-1]) - dZm[cut-1]/(dZp[cut+1]**2 + dZp[cut+1]*dZm[cut-1])
    E = -dZp[cut+1]/(dZm[cut-1]**2 + dZp[cut+1]*dZm[cut-1])
    F = dZm[cut-1]/(dZp[cut+1]**2 + dZp[cut+1]*dZm[cut-1])
    dphidZ = D*poti + E*potim1 + F*potip1
    dphidZ_an = np.asarray(dphidZ)
    
    return dBdZ_an, dbrdZ_an, dbzdZ_an, dbzetadZ_an, dbrdR_an, dbzdR_an, dbzetadR_an, dBdR_an, dphidR_an, dphidZ_an

def der_comp(cut_an, cut_c):
    '''Compares all derivatives between the rectangular and the angular grid. The comparison is along a cut but care must be taken to 
    use a cut that corresponds to the same physical Z-value on both grids, or as close as possible. Compare cut_c*core.unitZ+core.Zmin
    with angle.Z_fp[cut_an].
    '''
    #loading derivatives
    dBdZ_an, dbrdZ_an, dbzdZ_an, dbzetadZ_an, dbrdR_an, dbzdR_an, dbzetadR_an, dBdR_an, dphidR_an, dphidZ_an = angle_der(cut_an)
    dBdZ_c, dbrdZ_c, dbzdZ_c, dbzetadZ_c, dbrdR_c, dbzdR_c, dbzetadR_c, dBdR_c, dphidZ_c, dphidR_c = core.core_der(cut_c)
    #Major radius
    R = np.array([ip*core.unitR+core.Rmin for ip in range(0,len(core.Ri))])
    R_n = R_fp+core.Rmaj
    #Plotting
    plt.title("Comparison dphidZ")
    plt.plot(R,dphidZ_c,'b-',label='rectangular')
    plt.plot(R_n,dphidZ_an,'r-',label='angle')
    plt.xlabel('R(m)')
    plt.legend()
    plt.show()

def comparison():
    '''Compares loaded values between the two grids. Essentialy, how well the interpolation works on both grids. Care must be taken to
    compare points that correspond to the same physical R and Z-values. For choice of cut compare cut_c*core.unitZ+core.Zmin with
    angle.Z_fp[cut_an] and for choice of ip_value compare ip_value_c*core.unitR+core.Rmin with angle.R_fp[ip_value_an]+core.Rmaj.
    '''
    #loading values
    #Br_angle = core.getcutvalue_hor(core.bfield[:,0],3,2)
    #Bz_angle = core.getcutvalue_hor(core.bfield[:,1],3,2)
    #Bzeta_angle = core.getcutvalue_hor(core.bfield[:,2],3,2)
    #Br_rect = core.getcutvalue_hor(core.bfield[:,0],92,1)
    #Bz_rect = core.getcutvalue_hor(core.bfield[:,1],92,1)
    #Bzeta_rect = core.getcutvalue_hor(core.bfield[:,2],92,1)
    pot_angle = core.getcutvalue_hor(core.pot[:,18,0],3,2)
    pot_rect = core.getcutvalue_hor(core.pot[:,18,0],92,1)
    #n_angle = core.getcutvalue_hor(core.ne[:,18,0],3,2)
    #n_rect = core.getcutvalue_hor(core.ne[:,18,0],92,1)
    #Major Radius
    R_n = R_fp+core.Rmaj
    R = [x*core.unitR+core.Rmin for x in range(len(core.Ri))]
    #Plotting
    plt.title("Comparison pot")
    plt.plot(R,pot_rect,'b-',label='rectangular')
    plt.plot(R_n,pot_angle,'r-',label='angle')
    plt.xlabel('R(m)')
    plt.legend()
    plt.show()

'''Following functions calculate the various fluxes.'''

def mta(arr, ts_max, time_range):
    '''Performs a moving time average of an array that is already toroidally averaged. Returns an array of averages the same size.'''
    l=1
    m=0
    arr_m = []
    for i in range(0,ts_max):
        arr_m.append(np.mean(arr[i-m:i+ts_max]))
        m=m+1
    for i in range(ts_max,time_range-ts_max):#center
        arr_m.append(np.mean(arr[i-ts_max:i+ts_max]))
    for i in range(time_range-ts_max,time_range):#right side
        arr_m.append(np.mean(arr[i-ts_max-l:i+ts_max-l]))        
        l=l+1
    arr_avg = np.asarray(arr_m)
    return arr_avg

def exb_fluxes_angle(cut, Flux_ip, moving):
    '''Calculates the particle equilibrium and turbulent ExB fluxes at a point. You can choose to time average over the whole time
    range of perform a moving time average.
    '''
    global VR_all, ne_all, VZ_all, br, bz, triObj, RA, ZA, tci, Sep_ip,start
    #Inputs:
    adoption = 3 #Choose to run with: 1 = adiabatic density, 2 = non-adiabatic density, 3 = full density
    option = 2 #option for grid choice to do interpolations.
    time_range = 2 #Values used: 152 #ti255_shorter:149,ti255_short:194, ti255_long:259, ti253:125, ti262:152
    start = 0 #Specify start of loading at the xgc module when linear phase ends. Modified xgc always puts time start at zero index. 
    ts_max = 30 #Size of window of moving time average. 30 looks like the optimum.
    
    if adoption == 1:
        n_e = core.loader.calcNeAdiabatic()
    if adoption == 2:
        n_e = core.loader.eden
    if adoption == 3:
        n_e = core.loader.calcNeTotal()
        
    temp = np.array([[getcutvRvZ(iz,it,cut) for iz in range(core.Nplanes)] for it in range(start,start+time_range)])
    VR_all = temp[:,:,0,Flux_ip]
    VZ_all = temp[:,:,1,Flux_ip]
    tVR_all = temp[:,:,2,Flux_ip]
    tVZ_all = temp[:,:,3,Flux_ip]
    dphidR_all = temp[:,:,4,Flux_ip]
    dphidZ_all = temp[:,:,5,Flux_ip]
    poti_all = temp[:,:,6,Flux_ip]
    ne_all = np.array([[core.getcutvalue_hor(n_e[:,iz,it],cut,option)[Flux_ip] for iz in range(core.Nplanes)] for it in range(start,start+time_range)])
    
    br = core.getcutvalue_hor(core.bfield[:,0],cut,option)
    bz = core.getcutvalue_hor(core.bfield[:,1],cut,option)
    Bp = np.array(np.sqrt(br[:] * br[:] + bz[:] * bz[:]))
    
    ne_tor_avg = ne_all.mean(axis=1)
    VR_tor_avg = VR_all.mean(axis=1)
    VZ_tor_avg = VZ_all.mean(axis=1)
    tVR_tor_avg = tVR_all.mean(axis=1)
    tVZ_tor_avg = tVZ_all.mean(axis=1)
    dphidR_tor_avg = dphidR_all.mean(axis=1)
    dphidZ_tor_avg = dphidZ_all.mean(axis=1)
    poti_tor_avg = poti_all.mean(axis=1)
    
    if moving == True:
        ne_t = mta(ne_tor_avg, ts_max, time_range)
        #VR_t = mta(VR_tor_avg, ts_max, time_range)
        #VZ_t = mta(VZ_tor_avg, ts_max, time_range)
        tVR_t = mta(tVR_tor_avg, ts_max, time_range)
        tVZ_t = mta(tVZ_tor_avg, ts_max, time_range)
        dn = np.array(ne_all[:,:] - ne_t[:,np.newaxis])
        dVR = np.array(tVR_all[:,:] - tVR_t[:,np.newaxis])
        dVZ = np.array(tVZ_all[:,:] - tVZ_t[:,np.newaxis])
    else:
        ne_t = ne_tor_avg.mean()
        #VR_t = VR_tor_avg.mean()
        #VZ_t = VZ_tor_avg.mean()
        tVR_t = tVR_tor_avg.mean()
        tVZ_t = tVZ_tor_avg.mean()
        dn = np.array(ne_all[:,:] - ne_t)
        dVR = np.array(tVR_all[:,:] - tVR_t)
        dVZ = np.array(tVZ_all[:,:] - tVZ_t)
    
    ne_avg = ne_tor_avg.mean(axis=0)
    VR_avg = VR_tor_avg.mean(axis=0)
    VZ_avg = VZ_tor_avg.mean(axis=0)
    dphidR_avg = dphidR_tor_avg.mean(axis=0)
    dphidZ_avg = dphidZ_tor_avg.mean(axis=0)
    poti_avg = poti_tor_avg.mean(axis=0)
    
    '''Calculation of equilibrium flux as <<n>_zeta <V>_zeta>_t.'''
    Eq_R_flux = np.array(ne_tor_avg[:] * VR_tor_avg[:])
    Eq_Z_flux = np.array(ne_tor_avg[:] * VZ_tor_avg[:])
    Eq_Gamma_R = Eq_R_flux.mean() 
    #print("Eq_R=", Eq_Gamma_R)
    Eq_Gamma_Z = Eq_Z_flux.mean()
    #print("Eq_Z=", Eq_Gamma_Z)
    Eq_Gamma = np.array((-br[Flux_ip] * Eq_Z_flux[:] + bz[Flux_ip] * Eq_R_flux[:])/Bp[Flux_ip])
    Eq_Gamma = Eq_Gamma.mean()
    
    '''Calculation of mean velocities'''
    VR_avg = VR_tor_avg.mean(axis=0)
    VZ_avg = VZ_tor_avg.mean(axis=0)
    VN = ((-br[Flux_ip] * VZ_avg + bz[Flux_ip] * VR_avg)/Bp[Flux_ip])

    '''Calculation of ringing term as <<n>>_{zeta,t}<<V>>_{zeta,t} - <<n>_zeta <V>_zeta>_t.'''
    Ring_R_flux = (ne_avg * VR_avg) - Eq_Gamma_R #first piece of ringing term
    #print("Ring_R1 =", ne_avg * VR_avg)
    #print("Ring_R =", Ring_R_flux)
    Ring_Z_flux = (ne_avg * VZ_avg) - Eq_Gamma_Z #first piece of ringing term
    #print("Ring_Z1 =", ne_avg * VZ_avg)
    #print("Ring_Z =", Ring_Z_flux)
    Ring_Gamma = ((-br[Flux_ip] * Ring_Z_flux + bz[Flux_ip] * Ring_R_flux)/Bp[Flux_ip])
    #print("Ring =", Ring_Gamma)
            
    '''Calculation of turbulent flux as <dn dV>_{zeta,t}.'''
    Tur_R_flux = np.array([[dn[it,pl] * dVR[it,pl] for it in range(0,time_range)] for pl in range(core.Nplanes)])
    Tur_Z_flux = np.array([[dn[it,pl] * dVZ[it,pl] for it in range(0,time_range)] for pl in range(core.Nplanes)])
    Tur_R_flux_tor_avg = Tur_R_flux.mean(axis=1)
    Tur_Z_flux_tor_avg = Tur_Z_flux.mean(axis=1)
    Tur_R_flux_time_avg = Tur_R_flux_tor_avg.mean()
    Tur_Z_flux_time_avg = Tur_Z_flux_tor_avg.mean()
    Tur_Gamma = np.array((-br[Flux_ip] * Tur_Z_flux_time_avg + bz[Flux_ip] * Tur_R_flux_time_avg)/Bp[Flux_ip])
    
    print('flux point done')
    
    return Eq_Gamma, Tur_Gamma, Ring_Gamma#, ne_avg, dphidR_avg, dphidZ_avg, poti_avg, VR_avg, VZ_avg, Bp[Flux_ip], VN 

def check():    
    '''Simple check to see if the values are computed correctly.'''
    angle_mesh()
    file = open("Check_file_complex_quantities.txt",'a')
    file.write("Ang"+"\t"+"dpdR"+"\t"+"dpdZ"+"\t"+"vR"+"\t"+"vZ"+"\t"+"VN"+"\n")
    #file.write("Ang"+"\t"+"phi"+"Bp"+"\n")
    for i in range(1, len(R_fp)-1):
        R_val = R_fp[i]
        Z_val = Z_fp[i]
        Ang = norm_atan(Z_val,R_val)
        _,_,_,n,dpdR,dpdZ,phi,vR,vZ,Bp,VN = exb_fluxes_angle(i,i,False)
        file.write(str(Ang)+"\t"+str(dpdR)+"\t"+str(dpdZ)+"\t"+str(vR)+"\t"+str(vZ)+"\t"+str(VN)+"\n")
        #file.write(str(Ang)+"\t"+str(phi)+"\t"+str(Bp)+"\n")
    file.close()

def magnetic_flux_angle(cut,Flux_ip):
    '''Returns the magnetic flux from a point.'''
    global VR_all, ne_all, VZ_all, br, bz, triObj, RA, ZA, tci, Sep_ip, start
    #Inputs:
    option = 2
    time_range = 2 #look exb_fluxes_angle()for numbers
    start = 0 #start where linear phase ends, look three_fluxes_angle() for numbers 
    
    #density loading
    n_e=core.loader.calcNeTotal()
    ne_all = np.array([[core.getcutvalue_hor(n_e[:,iz,it],cut,option)[Flux_ip] for iz in range(core.Nplanes)] for it in range(start,start+time_range)])
    ne_tor_avg = ne_all.mean(axis=1)
    
    #Magnetic drifts
    gradBR,gradBZ,_,curvR,curvZ,_ = magnetic_drifts_angle(cut,Flux_ip)
    
    #Magnetic field
    br = core.getcutvalue_hor(core.bfield[:,0],cut,option)
    bz = core.getcutvalue_hor(core.bfield[:,1],cut,option)
    Bp=np.array(np.sqrt(br[:]*br[:] + bz[:]*bz[:]))
    
    #Magnetic Flux
    Mag_R_flux = np.array(ne_tor_avg[:]*(gradBR+curvR))
    Mag_Z_flux = np.array(ne_tor_avg[:]*(gradBZ+curvZ))
    Mag_Gamma = np.array((-br[Flux_ip]*Mag_Z_flux[:] + bz[Flux_ip]*Mag_R_flux[:])/Bp[Flux_ip])
    Mag_Gamma = Mag_Gamma.mean()
    
    return Mag_Gamma
    
def ion_heat_flux_angle(cut,Flux_ip,moving):
    '''Calculates the ion exb equilibrium and turbulent heat flux.'''
    global VR_all, ne_all, VZ_all, br, bz, triObj, RA, ZA, tci, Sep_ip, start
    #Inputs:
    option = 2
    time_range = 200 #ti255_shorter:149,ti255_short:194, ti255_long:259, ti253:125
    start = 0 #start where linear phase ends:ti255_shorter:490, ti255_short:445, ti255_long:380, ti253:200
    ts_max = 30 #30 looks like the optimum
    
    temp = np.array([[getcutvRvZ(iz,it,cut) for iz in range(core.Nplanes)] for it in range(start,start+time_range)])
    VR_all = temp[:,:,0,Flux_ip]
    VZ_all = temp[:,:,1,Flux_ip]
    print("VR_all done...")
    print("VZ_all done...")
    
    n_e = core.loader.calcNeTotal()
    ne_all = np.array([[core.getcutvalue_hor(n_e[:,iz,it],cut,option)[Flux_ip] for iz in range(core.Nplanes)] for it in range(start,start+time_range)])
    print("ne_all done...")
    
    Ti_perp_all = np.array([[map_array(core.i_T_perp,(iz-1)%core.Nplanes,it,cut)[Flux_ip] for iz in range(core.Nplanes)] for it in range(start,start+time_range)])
    print("T_perp done...")
    
    Ei_para_all = np.array([[map_array(core.i_E_para,(iz-1)%core.Nplanes,it,cut)[Flux_ip] for iz in range(core.Nplanes)] for it in range(start,start+time_range)])
    print("T_par done...")
    
    Temperature = 2/3.*(Ti_perp_all + Ei_para_all) 
    Pi_all = np.multiply(ne_all,Temperature)
    
    Pi_tor_avg = Pi_all.mean(axis=1)
    VR_tor_avg = VR_all.mean(axis=1)
    VZ_tor_avg = VZ_all.mean(axis=1)
    
    br = core.getcutvalue_hor(core.bfield[:,0],cut,option)
    bz = core.getcutvalue_hor(core.bfield[:,1],cut,option)
    Bp = np.array(np.sqrt(br[:]*br[:] + bz[:]*bz[:]))
    
    if moving == True:
        Pi_avg = mta(Pi_tor_avg, ts_max, time_range)
        VR_avg = mta(VR_tor_avg, ts_max, time_range)
        VZ_avg = mta(VZ_tor_avg, ts_max, time_range)
        dP = np.array(Pi_all[:,:] - Pi_avg[:,np.newaxis])
        dVR = np.array(VR_all[:,:] - VR_avg[:,np.newaxis])
        dVZ = np.array(VZ_all[:,:] - VZ_avg[:,np.newaxis])
    else:
        Pi_avg = Pi_tor_avg.mean()
        VR_avg = VR_tor_avg.mean()
        VZ_avg = VZ_tor_avg.mean()
        dP = np.array(Pi_all[:,:] - Pi_avg)
        dVR = np.array(VR_all[:,:] - VR_avg)
        dVZ = np.array(VZ_all[:,:] - VZ_avg)
    
    '''Calculation of equilibrium flux as <<P>_zeta <V>_zeta>_t.'''
    if moving == True:
        Eq_R_flux = np.array(Pi_tor_avg[:] * VR_tor_avg[:])
        Eq_Z_flux = np.array(Pi_tor_avg[:] * VZ_tor_avg[:])
        Eq_Gamma_Z = Eq_Z_flux.mean() #keep that seperately cause it might be useful for other purposes.
        Eq_Gamma = np.array((-br[Flux_ip] * Eq_Z_flux[:] + bz[Flux_ip] * Eq_R_flux[:])/Bp[Flux_ip])
        Eq_Gamma = Eq_Gamma.mean()
    else:
        '''Calculation of equilibrium flux as <<n>>_{zeta,t}<<V>>_{zeta,t}.'''
        Eq_R_flux = Pi_avg * VR_avg
        Eq_Z_flux = Pi_avg * VR_avg
        Eq_Gamma = (-br[Flux_ip] * Eq_Z_flux + bz[Flux_ip] * Eq_R_flux)/Bp[Flux_ip]

    '''Calculation of turbulent flux as <dn dV>_{zeta,t}.'''
    Tur_R_flux = np.array([[dP[it,pl] * dVR[it,pl] for it in range(0,time_range)] for pl in range(core.Nplanes)])
    Tur_Z_flux = np.array([[dP[it,pl] * dVZ[it,pl] for it in range(0,time_range)] for pl in range(core.Nplanes)])
    Tur_R_flux_tor_avg = Tur_R_flux.mean(axis=1)
    Tur_Z_flux_tor_avg = Tur_Z_flux.mean(axis=1)
    Tur_R_flux_time_avg = Tur_R_flux_tor_avg.mean()
    Tur_Z_flux_time_avg = Tur_Z_flux_tor_avg.mean()
    Tur_Gamma = np.array((-br[Flux_ip] * Tur_Z_flux_time_avg + bz[Flux_ip] * Tur_R_flux_time_avg)/Bp[Flux_ip])
    
    Tot_flux = Eq_Gamma + Tur_Gamma #Keep the total flux.
    
    print('flux point done')
    
    return Eq_Gamma, Tur_Gamma

def electron_heat_flux_angle(cut,Flux_ip,moving):
    '''Calculates the electron exb equilibrium and turbulent heat flux.'''
    global VR_all, ne_all, VZ_all, br, bz, triObj, RA, ZA, tci, Sep_ip, start
    #Inputs:
    option = 2
    time_range = 200 #ti255_shorter:149,ti255_short:194, ti255_long:259, ti253:125
    start = 0 #start where linear phase ends:ti255_shorter:490, ti255_short:445, ti255_long:380, ti253:200
    ts_max = 30 #30 looks like the optimum
    
    temp = np.array([[getcutvRvZ(iz,it,cut) for iz in range(core.Nplanes)] for it in range(start,start+time_range)])
    VR_all = temp[:,:,0,Flux_ip]
    VZ_all = temp[:,:,1,Flux_ip]
    print("VR_all done...")
    print("VZ_all done...")
    
    n_e = core.loader.calcNeTotal()
    ne_all = np.array([[core.getcutvalue_hor(n_e[:,iz,it],cut,option)[Flux_ip] for iz in range(core.Nplanes)] for it in range(start,start+time_range)])
    print("ne_all done...")
    
    Te_perp_all = np.array([[map_array(core.e_T_perp,(iz-1)%core.Nplanes,it,cut)[Flux_ip] for iz in range(core.Nplanes)] for it in range(start,start+time_range)])
    print("T_perp done...")
    
    Ee_para_all = np.array([[map_array(core.e_E_para,(iz-1)%core.Nplanes,it,cut)[Flux_ip] for iz in range(core.Nplanes)] for it in range(start,start+time_range)])
    print("T_par done...")
    
    Temperature = 2/3.*(Te_perp_all + Ee_para_all) 
    Pe_all = np.multiply(ne_all,Temperature)
    
    Pe_tor_avg = Pe_all.mean(axis=1)
    VR_tor_avg = VR_all.mean(axis=1)
    VZ_tor_avg = VZ_all.mean(axis=1)
    
    br = core.getcutvalue_hor(core.bfield[:,0],cut,option)
    bz = core.getcutvalue_hor(core.bfield[:,1],cut,option)
    Bp = np.array(np.sqrt(br[:]*br[:] + bz[:]*bz[:]))
    
    if moving == True:
        Pe_avg = mta(Pi_tor_avg, ts_max, time_range)
        VR_avg = mta(VR_tor_avg, ts_max, time_range)
        VZ_avg = mta(VZ_tor_avg, ts_max, time_range)
        dP = np.array(Pi_all[:,:] - Pe_avg[:,np.newaxis])
        dVR = np.array(VR_all[:,:] - VR_avg[:,np.newaxis])
        dVZ = np.array(VZ_all[:,:] - VZ_avg[:,np.newaxis])
    else:
        Pe_avg = Pe_tor_avg.mean()
        VR_avg = VR_tor_avg.mean()
        VZ_avg = VZ_tor_avg.mean()
        dP = np.array(Pe_all[:,:] - Pe_avg)
        dVR = np.array(VR_all[:,:] - VR_avg)
        dVZ = np.array(VZ_all[:,:] - VZ_avg)
    
    '''Calculation of equilibrium flux as <<P>_zeta <V>_zeta>_t.'''
    if moving == True:
        Eq_R_flux = np.array(Pe_tor_avg[:] * VR_tor_avg[:])
        Eq_Z_flux = np.array(Pe_tor_avg[:] * VZ_tor_avg[:])
        Eq_Gamma_Z = Eq_Z_flux.mean() #keep that seperately cause it might be useful for other purposes.
        Eq_Gamma = np.array((-br[Flux_ip] * Eq_Z_flux[:] + bz[Flux_ip] * Eq_R_flux[:])/Bp[Flux_ip])
        Eq_Gamma = Eq_Gamma.mean()
    else:
        '''Calculation of equilibrium flux as <<n>>_{zeta,t}<<V>>_{zeta,t}.'''
        Eq_R_flux = Pe_avg * VR_avg
        Eq_Z_flux = Pe_avg * VR_avg
        Eq_Gamma = (-br[Flux_ip] * Eq_Z_flux + bz[Flux_ip] * Eq_R_flux)/Bp[Flux_ip]

    '''Calculation of turbulent flux as <dn dV>_{zeta,t}.'''
    Tur_R_flux = np.array([[dP[it,pl] * dVR[it,pl] for it in range(0,time_range)] for pl in range(core.Nplanes)])
    Tur_Z_flux = np.array([[dP[it,pl] * dVZ[it,pl] for it in range(0,time_range)] for pl in range(core.Nplanes)])
    Tur_R_flux_tor_avg = Tur_R_flux.mean(axis=1)
    Tur_Z_flux_tor_avg = Tur_Z_flux.mean(axis=1)
    Tur_R_flux_time_avg = Tur_R_flux_tor_avg.mean()
    Tur_Z_flux_time_avg = Tur_Z_flux_tor_avg.mean()
    Tur_Gamma = np.array((-br[Flux_ip] * Tur_Z_flux_time_avg + bz[Flux_ip] * Tur_R_flux_time_avg)/Bp[Flux_ip])
    
    Tot_flux = Eq_Gamma + Tur_Gamma #Keep the total flux.
    
    print('flux point done')
    
    return Eq_Gamma, Tur_Gamma

'''Following functions return useful to know quantities.'''
    
def mag_comp(cut,ip_value):
    '''Returns the components of the magnetic field at a point.'''
    global RA,ZA,R_fp,Z_fp,pot,bfield,B2
    option=2
    Br = core.getcutvalue_hor(core.bfield[:,0],cut,option)
    Bz = core.getcutvalue_hor(core.bfield[:,1],cut,option)
    Bzeta = core.getcutvalue_hor(core.bfield[:,2],cut,option)
    return Br[ip_value], Bz[ip_value]
    
def LTeinv(cut,ip):
    '''Returns toroidal and time averaged inverse LTi.'''
    global RA,ZA,R_fp,Z_fp
    option=2
    if cut==None:
        cut = core.jcut
    
    Rp = np.roll(R_fp,1)
    Rm = np.roll(R_fp,-1)
    dRp = R_fp-Rp
    dRm = Rm - R_fp
    
    Zp = np.roll(Z_fp,1)
    Zm = np.roll(Z_fp,-1)
    dZp = Z_fp-Zp
    dZm = Zm - Z_fp

    Te_perp_all = np.array([[map_array(core.e_T_perp,(iz-1)%core.Nplanes,it,cut) for iz in range(core.Nplanes)]for it in range(2)]) 
    Ee_para_all = np.array([[map_array(core.e_E_para,(iz-1)%core.Nplanes,it,cut)for iz in range(core.Nplanes)]for it in range(2)]) 
    Te_perp_tavg = Te_perp_all.mean(axis=0)
    Ee_para_tavg = Ee_para_all.mean(axis=0)
    Te_perp = Te_perp_tavg.mean(axis=0)
    Ee_para = Ee_para_tavg.mean(axis=0)
    Te = 2/3.*(Te_perp + Ee_para) 
    
    dTedR = []
    for i in range(1,len(Te)-1):
        A = dRp[i+1]/(dRm[i-1]**2 + dRp[i+1]*dRm[i-1]) - dRm[i-1]/(dRp[i+1]**2 + dRp[i+1]*dRm[i-1])
        B = -dRp[i+1]/(dRm[i-1]**2 + dRp[i+1]*dRm[i-1])
        C = dRm[i-1]/(dRp[i+1]**2 + dRp[i+1]*dRm[i-1])
        dTedR.append(A*Te[i] + B*Te[i-1] + C*Te[i+1])
    dTedR.append((Te[-1]-Te[-2])/dRp[-1])
    dTedR = [(Te[1]-Te[0])/dRm[0]] + dTedR
    
    Te_perp_m1all = np.array([[map_array(core.e_T_perp,(iz-1)%core.Nplanes,it,cut-1) for iz in range(core.Nplanes)]for it in range(2)]) 
    Ee_para_m1all = np.array([[map_array(core.e_E_para,(iz-1)%core.Nplanes,it,cut-1)for iz in range(core.Nplanes)]for it in range(2)]) 
    Te_perp_tavgm1 = Te_perp_m1all.mean(axis=0)
    Ee_para_tavgm1 = Ee_para_m1all.mean(axis=0)
    Te_perpm1 = Te_perp_tavgm1.mean(axis=0)
    Ee_param1 = Ee_para_tavgm1.mean(axis=0)
    Tem1 = 2/3.*(Te_perpm1 + Ee_param1) 
    Te_perp_p1all = np.array([[map_array(core.e_T_perp,(iz-1)%core.Nplanes,it,cut+1) for iz in range(core.Nplanes)]for it in range(2)]) 
    Ee_para_p1all = np.array([[map_array(core.e_E_para,(iz-1)%core.Nplanes,it,cut+1)for iz in range(core.Nplanes)]for it in range(2)]) 
    Te_perp_tavgp1 = Te_perp_p1all.mean(axis=0)
    Ee_para_tavgp1 = Ee_para_p1all.mean(axis=0)
    Te_perpp1 = Te_perp_tavgp1.mean(axis=0)
    Ee_parap1 = Ee_para_tavgp1.mean(axis=0)
    Tep1 = 2/3.*(Te_perpp1 + Ee_parap1) 
    
    D = dZp[cut+1]/(dZm[cut-1]**2 + dZp[cut+1]*dZm[cut-1]) - dZm[cut-1]/(dZp[cut+1]**2 + dZp[cut+1]*dZm[cut-1])
    E = -dZp[cut+1]/(dZm[cut-1]**2 + dZp[cut+1]*dZm[cut-1])
    F = dZm[cut-1]/(dZp[cut+1]**2 + dZp[cut+1]*dZm[cut-1])
    dTedZ = D*Te + E*Tem1 + F*Tep1
    
    BRi = core.getcutvalue_hor(core.bfield[:,0],cut,option)
    BZi = core.getcutvalue_hor(core.bfield[:,1],cut,option)
    Bp = np.sqrt(np.power(BRi,2)+np.power(BZi,2))
    
    dTedr = -(BRi/Bp)*dTedZ + (BZi/Bp)*dTedR
    
    LTeinv = np.absolute(dTedr)/Te   
    return LTeinv[ip]

def LTiinv(cut,ip):
    '''Returns toroidal and time averaged inverse LTi.'''
    global RA,ZA,R_fp,Z_fp
    option=2
    if cut==None:
        cut = core.jcut
       
    Rp = np.roll(R_fp,1)
    Rm = np.roll(R_fp,-1)
    dRp = R_fp-Rp
    dRm = Rm - R_fp
    
    Zp = np.roll(Z_fp,1)
    Zm = np.roll(Z_fp,-1)
    dZp = Z_fp-Zp
    dZm = Zm - Z_fp
    
    Ti_perp_all = np.array([[map_array(core.i_T_perp,(iz-1)%core.Nplanes,it,cut) for iz in range(core.Nplanes)]for it in range(2)]) 
    Ei_para_all = np.array([[map_array(core.i_E_para,(iz-1)%core.Nplanes,it,cut)for iz in range(core.Nplanes)]for it in range(2)]) 
    Ti_perp_tavg = Ti_perp_all.mean(axis=0)
    Ei_para_tavg = Ei_para_all.mean(axis=0)
    Ti_perp = Ti_perp_tavg.mean(axis=0)
    Ei_para = Ei_para_tavg.mean(axis=0)
    Ti = 2/3.*(Ti_perp + Ei_para) 
    
    dTidR = []
    for i in range(1,len(Ti)-1):
        A = dRp[i+1]/(dRm[i-1]**2 + dRp[i+1]*dRm[i-1]) - dRm[i-1]/(dRp[i+1]**2 + dRp[i+1]*dRm[i-1])
        B = -dRp[i+1]/(dRm[i-1]**2 + dRp[i+1]*dRm[i-1])
        C = dRm[i-1]/(dRp[i+1]**2 + dRp[i+1]*dRm[i-1])
        dTidR.append(A*Ti[i] + B*Ti[i-1] + C*Ti[i+1])
    dTidR.append((Ti[-1]-Ti[-2])/dRp[-1])
    dTidR = [(Ti[1]-Ti[0])/dRm[0]] + dTidR
    
    Ti_perp_m1all = np.array([[map_array(core.i_T_perp,(iz-1)%core.Nplanes,it,cut-1) for iz in range(core.Nplanes)]for it in range(2)]) 
    Ei_para_m1all = np.array([[map_array(core.i_E_para,(iz-1)%core.Nplanes,it,cut-1)for iz in range(core.Nplanes)]for it in range(2)]) 
    Ti_perp_tavgm1 = Ti_perp_m1all.mean(axis=0)
    Ei_para_tavgm1 = Ei_para_m1all.mean(axis=0)
    Ti_perpm1 = Ti_perp_tavgm1.mean(axis=0)
    Ei_param1 = Ei_para_tavgm1.mean(axis=0)
    Tim1 = 2/3.*(Ti_perpm1 + Ei_param1) 
    Ti_perp_p1all = np.array([[map_array(core.i_T_perp,(iz-1)%core.Nplanes,it,cut+1) for iz in range(core.Nplanes)]for it in range(2)]) 
    Ei_para_p1all = np.array([[map_array(core.i_E_para,(iz-1)%core.Nplanes,it,cut+1)for iz in range(core.Nplanes)]for it in range(2)]) 
    Ti_perp_tavgp1 = Ti_perp_p1all.mean(axis=0)
    Ei_para_tavgp1 = Ei_para_p1all.mean(axis=0)
    Ti_perpp1 = Ti_perp_tavgp1.mean(axis=0)
    Ei_parap1 = Ei_para_tavgp1.mean(axis=0)
    Tip1 = 2/3.*(Ti_perpp1 + Ei_parap1) 
    
    D = dZp[cut+1]/(dZm[cut-1]**2 + dZp[cut+1]*dZm[cut-1]) - dZm[cut-1]/(dZp[cut+1]**2 + dZp[cut+1]*dZm[cut-1])
    E = -dZp[cut+1]/(dZm[cut-1]**2 + dZp[cut+1]*dZm[cut-1])
    F = dZm[cut-1]/(dZp[cut+1]**2 + dZp[cut+1]*dZm[cut-1])
    dTidZ = D*Ti + E*Tim1 + F*Tip1
    
    BRi = core.getcutvalue_hor(core.bfield[:,0],cut,option)
    BZi = core.getcutvalue_hor(core.bfield[:,1],cut,option)
    Bp = np.sqrt(np.power(BRi,2)+np.power(BZi,2))
    
    dTidr = -(BRi/Bp)*dTidZ + (BZi/Bp)*dTidR
    
    LTiinv = np.absolute(dTidr)/Ti    
    return LTiinv[ip]


def Lninv(cut,ip):
    '''Returns the inverse density length scale.'''
    global RA,ZA,R_fp,Z_fp
    option=2
    if cut==None:
        cut = core.jcut
       
    Rp = np.roll(R_fp,1)
    Rm = np.roll(R_fp,-1)
    dRp = R_fp-Rp
    dRm = Rm - R_fp
    
    Zp = np.roll(Z_fp,1)
    Zm = np.roll(Z_fp,-1)
    dZp = Z_fp-Zp
    dZm = Zm - Z_fp

    n_all = np.array([[core.getcutvalue_hor(core.ne[:,iz,it],cut,option) for iz in range(core.Nplanes)] for it in range(2)])
    n_tavg = n_all.mean(axis=0)
    n = n_tavg.mean(axis=0)
    
    dndR = []
    for i in range(1,len(n)-1):
        A = dRp[i+1]/(dRm[i-1]**2 + dRp[i+1]*dRm[i-1]) - dRm[i-1]/(dRp[i+1]**2 + dRp[i+1]*dRm[i-1])
        B = -dRp[i+1]/(dRm[i-1]**2 + dRp[i+1]*dRm[i-1])
        C = dRm[i-1]/(dRp[i+1]**2 + dRp[i+1]*dRm[i-1])
        dndR.append(A*n[i] + B*n[i-1] + C*n[i+1])
    dndR.append((n[-1]-n[-2])/dRp[-1])
    dndR = [(n[1]-n[0])/dRm[0]] + dndR
    
    n_m1all = np.array([[core.getcutvalue_hor(core.ne[:,iz,it],cut-1,option) for iz in range(core.Nplanes)] for it in range(2)])
    n_m1tavg = n_m1all.mean(axis=0)
    nm1 = n_m1tavg.mean(axis=0)
    
    n_p1all = np.array([[core.getcutvalue_hor(core.ne[:,iz,it],cut+1,option) for iz in range(core.Nplanes)] for it in range(2)])
    n_p1tavg = n_p1all.mean(axis=0)
    np1 = n_p1tavg.mean(axis=0)
    
    D = dZp[cut+1]/(dZm[cut-1]**2 + dZp[cut+1]*dZm[cut-1]) - dZm[cut-1]/(dZp[cut+1]**2 + dZp[cut+1]*dZm[cut-1])
    E = -dZp[cut+1]/(dZm[cut-1]**2 + dZp[cut+1]*dZm[cut-1])
    F = dZm[cut-1]/(dZp[cut+1]**2 + dZp[cut+1]*dZm[cut-1])
    dndZ = D*n + E*nm1 + F*np1
    
    BRi = core.getcutvalue_hor(core.bfield[:,0],cut,option)
    BZi = core.getcutvalue_hor(core.bfield[:,1],cut,option)
    Bp = np.sqrt(np.power(BRi,2)+np.power(BZi,2))
    
    dndr = -(BRi/Bp)*dndZ + (BZi/Bp)*dndR
    
    Lninv = np.absolute(dndr)/n
    return Lninv[ip]

def tmp(cut,Flux_ip):
    '''Returns average ion and electron total temperatures and perpendicular and parallel ion temperatures.'''
    option=2
    time_range=2
    start=0
    Te_perp_all = np.array([[core.getcutvalue_hor(core.e_T_perp[:,iz,it],cut,option)[Flux_ip] for iz in range(core.Nplanes)] for it in range(start,start+time_range)])
    Ee_para_all = np.array([[core.getcutvalue_hor(core.e_E_para[:,iz,it],cut,option)[Flux_ip] for iz in range(core.Nplanes)] for it in range(start,start+time_range)])
    T_e = 2/3.*(Te_perp_all + Ee_para_all)

    Ti_perp_all = np.array([[core.getcutvalue_hor(core.i_T_perp[:,iz,it],cut,option)[Flux_ip] for iz in range(core.Nplanes)] for it in range(start,start+time_range)])
    Ei_para_all = np.array([[core.getcutvalue_hor(core.i_E_para[:,iz,it],cut,option)[Flux_ip] for iz in range(core.Nplanes)] for it in range(start,start+time_range)])
    T_i = 2/3.*(Ti_perp_all + Ei_para_all)
    Ti_perp_tor = Ti_perp_all.mean(axis=1)
    Ei_para_tor = Ei_para_all.mean(axis=1)
    Ti_perp = Ti_perp_tor.mean(axis=0)
    Ei_para = Ei_para_tor.mean(axis=0)
    
    T_e_tor = T_e.mean(axis=1)
    T_i_tor = T_i.mean(axis=1)
    T_e_avg = T_e_tor.mean(axis=0)
    T_i_avg = T_i_tor.mean(axis=0)

    return T_i_avg,T_e_avg, Ti_perp, Ei_para

def density(cut,Flux_ip):
    '''Calculates toroidally and time averaged density.'''
    option=2
    time_range=10
    start=0
    n_all = np.array([[core.getcutvalue_hor(core.ne[:,iz,it],cut,option)[Flux_ip] for iz in range(core.Nplanes)] for it in range(start,start+time_range)])
    n_tavg = n_all.mean(axis=0)
    n = n_tavg.mean(axis=0)
    
    return n

def turbulence_strength(cut,Flux_ip,moving=False):
    '''Calculates the electrostatic perturbation strength.'''
    option=2
    time_range=200
    start=0
    ts_max=30 #30 looks like the optimum
    
    pot = np.array([[core.getcutvalue_hor(core.pot[:,iz,it],cut,option)[Flux_ip] for iz in range(core.Nplanes)] for it in range(start,start+time_range)])
    
    pot_tor_avg = pot.mean(axis=1)
    
    if moving == True:
        pot_avg = mta(pot_tor_avg, ts_max, time_range)
        dPhi = np.array(pot[:,:] - pot_avg[:,np.newaxis])
    else:
        pot_avg = pot_tor_avg.mean()
        dPhi = np.array(pot[:,:] - pot_avg)
        
    pot_avg = np.asarray(pot_avg)
    
    dPhi_tor = dPhi.mean(axis=1)
    dPhi = dPhi_tor.mean()  
    
    mean_pot = pot_tor_avg.mean()
    
    turbulence_strength = np.sqrt(np.mean(np.square(dPhi_tor)))/mean_pot
    
    return mean_pot, dPhi, turbulence_strength

def density_perturbation_strength(cut,Flux_ip):
    '''Calculates the density perturbation strength.'''
    option=2
    time_range=200
    start=0
    ts_max=30 #30 looks like the optimum
    ne_all = np.array([[core.getcutvalue_hor(core.ne[:,iz,it],cut,option)[Flux_ip] for iz in range(core.Nplanes)] for it in range(start,start+time_range)])
    ne_tor_avg = ne_all.mean(axis=1)
    l=1
    m=0
    ne_m = []
    for i in range(0,ts_max):
        ne_m.append(np.mean(ne_tor_avg[i-m:i+ts_max]))
        m=m+1
    for i in range(ts_max,time_range-ts_max):#center
        ne_m.append(np.mean(ne_tor_avg[i-ts_max:i+ts_max]))
    for i in range(time_range-ts_max,time_range):#right side
        ne_m.append(np.mean(ne_tor_avg[i-ts_max-l:i+ts_max-l]))
        l=l+1
    ne_avg = np.asarray(ne_m)
    dn = np.array(ne_all[:,:] - ne_avg[:,np.newaxis])
    dn_tor = dn.mean(axis=1)
    mean_ne = ne_tor_avg.mean()
    return np.sqrt(np.mean(np.square(dn_tor)))/mean_ne

def e_temp_perturbation_strength(cut,Flux_ip):
    '''Calculates the electron temperature perturbation strength.'''
    option=2
    time_range=200
    start=0
    ts_max=30 #30 looks like the optimum
    
    Te_perp_all = np.array([[core.getcutvalue_hor(core.e_T_perp[:,iz,it],cut,option)[Flux_ip] for iz in range(core.Nplanes)] for it in range(start,start+time_range)])
    Ee_para_all = np.array([[core.getcutvalue_hor(core.e_E_para[:,iz,it],cut,option)[Flux_ip] for iz in range(core.Nplanes)] for it in range(start,start+time_range)])
    T_e = 2/3.*(Te_perp_all + Ee_para_all)

 
    Te_tor_avg = T_e.mean(axis=1)
    l=1
    m=0
    Te_m = []
    for i in range(0,ts_max):
        Te_m.append(np.mean(Te_tor_avg[i-m:i+ts_max]))
        m=m+1
    for i in range(ts_max,time_range-ts_max):#center
        Te_m.append(np.mean(Te_tor_avg[i-ts_max:i+ts_max]))
    for i in range(time_range-ts_max,time_range):#right side
        Te_m.append(np.mean(Te_tor_avg[i-ts_max-l:i+ts_max-l]))
        l=l+1
    Te_avg = np.asarray(Te_m)
    dTe = np.array(T_e[:,:] - Te_avg[:,np.newaxis])
    dTe_tor = dTe.mean(axis=1)
    mean_Te = Te_tor_avg.mean()
    return np.sqrt(np.mean(np.square(dTe_tor)))/mean_Te

def i_temp_perturbation_strength(cut,Flux_ip):
    '''Calculates the ion temperature perturbation strength.'''
    option=2
    time_range=200
    start=0
    ts_max=30 #30 looks like the optimum
    
    Ti_perp_all = np.array([[core.getcutvalue_hor(core.i_T_perp[:,iz,it],cut,option)[Flux_ip] for iz in range(core.Nplanes)] for it in range(start,start+time_range)])
    Ei_para_all = np.array([[core.getcutvalue_hor(core.i_E_para[:,iz,it],cut,option)[Flux_ip] for iz in range(core.Nplanes)] for it in range(start,start+time_range)])
    T_i = 2/3.*(Ti_perp_all + Ei_para_all)

 
    Ti_tor_avg = T_i.mean(axis=1)
    l=1
    m=0
    Te_m = []
    for i in range(0,ts_max):
        Ti_m.append(np.mean(Ti_tor_avg[i-m:i+ts_max]))
        m=m+1
    for i in range(ts_max,time_range-ts_max):#center
        Ti_m.append(np.mean(Ti_tor_avg[i-ts_max:i+ts_max]))
    for i in range(time_range-ts_max,time_range):#right side
        Ti_m.append(np.mean(Ti_tor_avg[i-ts_max-l:i+ts_max-l]))
        l=l+1
    Ti_avg = np.asarray(Ti_m)
    dTi = np.array(T_i[:,:] - Ti_avg[:,np.newaxis])
    dTi_tor = dTi.mean(axis=1)
    mean_Ti = Ti_tor_avg.mean()
    return np.sqrt(np.mean(np.square(dTi_tor)))/mean_Ti


def i_pressure_perturbation_strength(cut,Flux_ip):
    '''Calculates the ion pressure perturbation strength.'''
    option=2
    time_range=200
    start=0
    ts_max=30 #30 looks like the optimum
    
    n_e = core.loader.calcNeTotal()
    ne_all = np.array([[core.getcutvalue_hor(n_e[:,iz,it],cut,option)[Flux_ip] for iz in range(core.Nplanes)] for it in range(start,start+time_range)])
    print("ne_all done...")
    
    Ti_perp_all = np.array([[map_array(core.i_T_perp,(iz-1)%core.Nplanes,it,cut)[Flux_ip] for iz in range(core.Nplanes)] for it in range(start,start+time_range)])
    print("T_perp done...")
    
    Ei_para_all = np.array([[map_array(core.i_E_para,(iz-1)%core.Nplanes,it,cut)[Flux_ip] for iz in range(core.Nplanes)] for it in range(start,start+time_range)])
    print("T_par done...")
    
    Temperature = 2/3.*(Ti_perp_all + Ei_para_all) 
    Pi_all = np.multiply(ne_all,Temperature)

 
    Pi_tor_avg = Pi_all.mean(axis=1)
    l=1
    m=0
    Pi_m = []
    for i in range(0,ts_max):
        Pi_m.append(np.mean(Pi_tor_avg[i-m:i+ts_max]))
        m=m+1
    for i in range(ts_max,time_range-ts_max):#center
        Pi_m.append(np.mean(Pi_tor_avg[i-ts_max:i+ts_max]))
    for i in range(time_range-ts_max,time_range):#right side
        Pi_m.append(np.mean(Pi_tor_avg[i-ts_max-l:i+ts_max-l]))
        l=l+1
    Pi_avg = np.asarray(Pi_m)
    dPi = np.array(Pi_all[:,:] - Pi_avg[:,np.newaxis])
    dPi_tor = dPi.mean(axis=1)
    mean_Pi = Pi_tor_avg.mean()
    return np.sqrt(np.mean(np.square(dPi_tor)))

def e_pressure_perturbation_strength(cut,Flux_ip):
    '''Calculates the electron pressure perturbation strength.'''
    option=2
    time_range=200
    start=0
    ts_max=30 #30 looks like the optimum
    
    n_e = core.loader.calcNeTotal()
    ne_all = np.array([[core.getcutvalue_hor(n_e[:,iz,it],cut,option)[Flux_ip] for iz in range(core.Nplanes)] for it in range(start,start+time_range)])
    print("ne_all done...")
    
    Te_perp_all = np.array([[map_array(core.e_T_perp,(iz-1)%core.Nplanes,it,cut)[Flux_ip] for iz in range(core.Nplanes)] for it in range(start,start+time_range)])
    print("T_perp done...")
    
    Ee_para_all = np.array([[map_array(core.e_E_para,(iz-1)%core.Nplanes,it,cut)[Flux_ip] for iz in range(core.Nplanes)] for it in range(start,start+time_range)])
    print("T_par done...")
    
    Temperature = 2/3.*(Te_perp_all + Ee_para_all) 
    Pe_all = np.multiply(ne_all,Temperature)

 
    Pe_tor_avg = Pe_all.mean(axis=1)
    l=1
    m=0
    Pe_m = []
    for i in range(0,ts_max):
        Pe_m.append(np.mean(Pe_tor_avg[i-m:i+ts_max]))
        m=m+1
    for i in range(ts_max,time_range-ts_max):#center
        Pe_m.append(np.mean(Pe_tor_avg[i-ts_max:i+ts_max]))
    for i in range(time_range-ts_max,time_range):#right side
        Pe_m.append(np.mean(Pe_tor_avg[i-ts_max-l:i+ts_max-l]))
        l=l+1
    Pe_avg = np.asarray(Pe_m)
    dPe = np.array(Pe_all[:,:] - Pe_avg[:,np.newaxis])
    dPe_tor = dPe.mean(axis=1)
    mean_Pe = Pe_tor_avg.mean()
    return np.sqrt(np.mean(np.square(dPe_tor)))


def magnetic_field(cut,Flux_ip):
    '''Calculates the magnitude of the total and poloidal magnetic field.'''
    option=2
    BRi = core.getcutvalue_hor(core.bfield[:,0],cut,option)
    BZi = core.getcutvalue_hor(core.bfield[:,1],cut,option)
    Bzetai = core.getcutvalue_hor(core.bfield[:,2],cut,option)
    Bp = np.sqrt(np.power(BRi,2)+np.power(BZi,2))
    Bm = np.sqrt(np.power(BRi,2)+np.power(BZi,2)+np.power(Bzetai,2))
    return Bp[Flux_ip], Bm[Flux_ip]
    
def density_perturbation(cut,Flux_ip):
    '''Reads and writes in files the density perturbation on a specific point for all times and planes.'''
    option=2
    time_range=2
    start=0
    ne_all = np.array([[core.getcutvalue_hor(core.ne[:,iz,it],cut,option)[Flux_ip] for iz in range(core.Nplanes)] for it in range(start,start+time_range)])
    ne_tor_avg = ne_all.mean(axis=1)
    ne_avg = ne_tor_avg.mean()
    
    dn = np.array(ne_all[:,:] - ne_avg)
    return dn

def line_reject(file_name):
    '''Rejects lines with nan's and strings.'''
    f = open(file_name,"r")
    f.seek(0) #takes pointer to the beginning of file.
    lines = f.readlines() #creates list of lines
    num_of_lines = len(lines)
    f.close()
    f = open(file_name,"w")
    for i in range(num_of_lines): #loops over lines and rewrites the ones without nan's and strings. Very important to close file.
        if "--" and "nan" not in lines[i]:
            f.write(lines[i])            
    f.close()


